# è®¿é—®åº”ç”¨ä¸“å±ç©ºé—´

##  è¯´æ˜

è®¸å¤šæƒ…å†µä¸‹ï¼Œåº”ç”¨åˆ›å»ºçš„æ–‡ä»¶å…¶å®ƒåº”ç”¨ä¸éœ€è¦ä¹Ÿä¸èƒ½å¤Ÿè®¿é—®ã€‚ä¸ºå­˜å‚¨åº”ç”¨çš„ä¸“å±æ–‡ä»¶ç³»ç»Ÿæä¾›äº†ä»¥ä¸‹ä¸¤ç§å­˜å‚¨ä½ç½® :

* å†…éƒ¨å­˜å‚¨ç›®å½•
* å¤–éƒ¨å­˜å‚¨ç›®å½•

### å†…éƒ¨å­˜å‚¨ç›®å½•

> The system prevents other apps from accessing these locations, and on Android 10 (API level 29) and higher, these locations are encrypted. These characteristics make these locations a good place to `store sensitive data` that only your app itself can access.

ç³»ç»Ÿä¿æŠ¤å…¶å®ƒåº”ç”¨è®¿é—®å†…éƒ¨å­˜å‚¨çš„ä½ç½®ï¼Œåœ¨Android 10 (API level 29)æˆ–æ›´é«˜çš„ç‰ˆæœ¬ä¸­ï¼Œè¿™äº›ä½ç½®æ˜¯åŠ å¯†çš„ğŸ”ï¼ˆç”¨10çš„æ‰‹æœºå¹¶ä¸ºå‘ç°åŠ å¯†ğŸ¤”ï¸ï¼‰ã€‚



å†…éƒ¨å­˜å‚¨é€‚ç”¨äºç”¨æˆ·å­˜å‚¨ä¸€äº›æ•æ„Ÿçš„æ•°æ®ã€‚

### å¤–éƒ¨å­˜å‚¨ç›®å½•

> Although it's possible for another app to access these directories if that app has the proper permissions, the files stored in these directories are meant for use only by your app. If you specifically intend to create files that other apps should be able to access, your app should store these files in the [shared storage](https://developer.android.google.cn/training/data-storage/shared) part of external storage instead.

å°½ç®¡è¿™ä¸ªä½ç½®å¾ˆå¯èƒ½è¢«å…¶å®ƒåº”ç”¨å»è®¿é—®ï¼Œå¦‚æœå…¶å®ƒåº”ç”¨æœ‰æ­£ç¡®çš„æƒé™çš„è¯ã€‚å¦‚æœå¼€å‘è€…æƒ³è®©è¿™äº›åˆ›å»ºçš„æ–‡ä»¶è¢«å…¶å®ƒåº”ç”¨è®¿é—®ï¼Œåº”è¯¥å°†å…¶æ”¾åœ¨å¤–éƒ¨å­˜å‚¨çš„å…±äº«ç©ºé—´ä¸­ã€‚

å½“ç”¨æˆ·å¸è½½åº”ç”¨æ—¶ï¼Œè¿™äº›å­˜å‚¨åœ¨åº”ç”¨ä¸“å±ç©ºé—´çš„æ–‡ä»¶æ˜¯è¦è¢«ç§»é™¤ã€‚ç”±äºæ­¤è¡Œä¸ºï¼Œå¼€å‘è€…ä¸åº”è¯¥ä½¿ç”¨è¿™äº›å­˜å‚¨ä½ç½®å»ä¿å­˜ä»»ä½•å¯¹ç”¨æˆ·æ¥è¯´æƒ³é•¿ä¹…ä¿å­˜çš„æ–‡ä»¶ã€‚ä¾‹å¦‚å¦‚æœä½ çš„åº”ç”¨å…è®¸ç”¨æˆ·å»æˆªå›¾ï¼Œç”¨æˆ·æƒ³ä»–ä»¬å†æ¬¡è®¿é—®è¿™å¼ ç…§ç‰‡å³ä¾¿åº”ç”¨è¢«å¸è½½äº†ï¼Œå› æ­¤åº”è¯¥ä½¿ç”¨å…±äº«å­˜å‚¨ç©ºé—´ä½œä¸ºæ›¿ä»£å»å­˜å‚¨ã€‚

æ¥ä¸‹æ¥çš„éƒ¨åˆ†è¯¦ç»†è®²è¿°å¦‚ä½•å­˜å‚¨å’Œè®¿é—®åº”ç”¨ä¸“å±ç›®å½•çš„æ–‡ä»¶ã€‚

## å†…éƒ¨å­˜å‚¨è®¿é—®

å¯¹äºä»»æ„ä¸€ä¸ªåº”ç”¨ï¼Œç³»ç»Ÿä¼šåœ¨å†…éƒ¨å­˜å‚¨ä¸­æä¾›ä¸€ä¸ªåº”ç”¨å¯ä»¥ç»„ç»‡è‡ªå·±æ–‡ä»¶ç›®å½•ã€‚ä¸€ä¸ªç›®å½•ä¸ºäº†åº”ç”¨æŒä¹…æ–‡ä»¶è€Œè®¾è®¡ï¼Œå¦ä¸€ä¸ªä¸ºäº†åº”ç”¨çš„ç¼“å­˜æ–‡ä»¶è€Œè®¾è®¡ã€‚åº”ç”¨è®¿é—®æ­¤å¤„ç›®å½•æ—¶æ— éœ€ä»»ä½•æƒé™ã€‚

å…¶å®ƒåº”ç”¨ä¸èƒ½è®¿é—®å­˜å‚¨åœ¨å†…éƒ¨ç©ºé—´çš„æ–‡ä»¶ï¼Œè¿™ä½¿å¾—å†…éƒ¨ç©ºé—´æˆä¸ºäº†åº”ç”¨å­˜å‚¨æ•°æ®çš„å¥½åœ°æ–¹ã€‚

æ³¨æ„âš ï¸ï¼šå†…éƒ¨å­˜å‚¨å¯¹æ‰‹æœºç©ºé—´å¾ˆçè´µï¼Œå› æ­¤åœ¨å¾€å†…éƒ¨å­˜å‚¨ç©ºé—´å†™æ–‡ä»¶æ—¶åº”æ£€æŸ¥ç©ºé—´å¤§å°ã€‚

### è®¿é—®æŒä¹…æ–‡ä»¶

Your app's ordinary, persistent files reside in a directory that you can access using the [`filesDir`](https://developer.android.google.cn/reference/android/content/Context#getFilesDir()) property of a context object. The framework provides several methods to help you access and store files in this directory.

#### è®¿é—®å’Œå­˜å‚¨æ–‡ä»¶

``` java
File file = new File(context.getFilesDir(), filename);
//è·¯å¾„:/data/data/åŒ…å/files
```

> æ³¨æ„: ä¸ºäº†ç»´æŒ`App`çš„æ­£å¸¸è¿è¡Œï¼Œä¸è¦å¤šæ¬¡æ‰“å¼€æˆ–å…³é—­ç›¸åŒçš„æ–‡ä»¶ã€‚

#####  å­˜å‚¨æ–‡ä»¶

``` java
String filename = "test.txt";
String fileContents = "Hello world!";
try (FileOutputStream fos = this.openFileOutput(filename, Context.MODE_PRIVATE)) {
      fos.write(fileContents.getBytes());
}
```

> åœ¨`Adroid7.0`åŠä»¥ä¸Šç‰ˆæœ¬ï¼Œåªæœ‰`Context.MODE_PRIVATE`æ¨¡å¼ï¼Œå…¶å®ƒæ¨¡å¼å‡ä¼šæŠ¥é”™ã€‚

##### è¯»å–æ–‡ä»¶

``` java
StringBuilder stringBuilder = new StringBuilder();
FileInputStream fileInputStream = FileStorageStudy.this.openFileInput(filename);
InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, StandardCharsets.UTF_8);
try (BufferedReader bufferedReader = new BufferedReader(inputStreamReader)){
      String line = bufferedReader.readLine();
      stringBuilder.append(line);
 } catch (IOException e) {
      e.printStackTrace();
 }finally {
      Toast.makeText(this, "content:"+stringBuilder.toString(), Toast.LENGTH_SHORT).show();
 }
```

> **Note:**  å¦‚æœéœ€è¦è®¿é—®æ–‡ä»¶ä½œä¸ºæµåœ¨å®‰è£…çš„æ—¶å€™ï¼Œå»ºè®®å°†æ–‡ä»¶æ”¾åœ¨`/res/raw`ç›®å½•ä¸‹ï¼Œå¼€å‘è€…å¯ä»¥é€šè¿‡`openRawResource`æ–¹æ³•æ‰“å¼€è¿™äº›æ–‡ä»¶ï¼Œåœ¨æ­¤ç›®å½•ä¸‹çš„æ–‡ä»¶ä¸`/res/drawable`ä¸åŒï¼Œä¸€å®šè¦å‡ºä¸»æ„ï¼

#### æŸ¥çœ‹æ–‡ä»¶åˆ—è¡¨

``` java
Array<String> files = context.fileList();
```

#### å†…éƒ¨å­˜å‚¨åˆ›å»ºç›®å½•

``` java
File directory = context.getFilesDir();
File file = new File(directory, filename);
```

> **Note:** `filesDir` is always an ancestor directory of this new directory.

### ç¼“å­˜æ–‡ä»¶

å†…éƒ¨å­˜å‚¨ç¼“å­˜æ–‡ä»¶ç”¨äºä¸´æ—¶æ”¾ç½®ä¸€äº›æ•æ„Ÿæ–‡ä»¶ï¼Œæ­¤æ–‡ä»¶åœ¨åº”ç”¨å¸è½½æ—¶ä¼šè‡ªåŠ¨æ¸…é™¤ï¼Œä½†æ˜¯å½“åº”ç”¨å†…éƒ¨ç©ºé—´ä¸å¤Ÿæ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°†æ­¤ç›®å½•ä¸‹çš„æ–‡ä»¶æ¸…é™¤æ‰ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨æ—¶è®°å¾—å¤„ç†ï¼Œæ­¤æ–‡ä»¶å¤¹ä¸‹çš„æ–‡ä»¶å¹¶ä¸ä¸€å®šå­˜åœ¨ï¼

> * å†…a
> * éƒ¨å­˜å‚¨ç¼“å­˜ç›®å½•ä»…ç”¨äºå­˜æ”¾å°æ•°æ®çš„ä¸´æ—¶æ–‡ä»¶ã€‚
> * å¯ä»¥ä½¿ç”¨`getCacheQuotaBytes()`æ–¹æ³•è·å–å ç”¨ç©ºé—´ã€‚

##### åˆ›å»ºç¼“å­˜æ–‡ä»¶

``` java 
File.createTempFile(filename, null, context.getCacheDir());
```

æˆ–è€…

``` jav
File cacheFile = new File(context.getCacheDir(), filename);
```

> **Caution:** When the device is low on internal storage space, Android may delete these cache files to recover space. So check for the existence of your cache files before reading them.

##### åˆ é™¤ç¼“å­˜æ–‡ä»¶

``` java
cacheFile.delete();
```

æˆ–è€…

``` java 
context.deleteFile(cacheFileName);
```

## å¤–éƒ¨å­˜å‚¨è®¿é—®

If internal storage doesn't provide enough space to store app-specific files, consider using external storage instead. The system provides directories within external storage where an app can organize files that provide value to the user only within your app. One directory is designed for [your app's persistent files](https://developer.android.google.cn/training/data-storage/app-specific#external-access-files), and another contains [your app's cached files](https://developer.android.google.cn/training/data-storage/app-specific#external-cache-create).

On Android 4.4 (API level 19) or higher, your app doesn't need to request any storage-related permissions to access app-specific directories within external storage. The files stored in these directories are removed when your app is uninstalled.

> **Caution:** The files in these directories aren't guaranteed to be accessible, such as when a removable SD card is taken out of the device. If your app's functionality depends on these files, you should instead store the files within [internal storage](https://developer.android.google.cn/training/data-storage/app-specific#internal).

On devices that run Android 9 (API level 28) or lower, any app can access app-specific files within external storage, provided that the other app has the appropriate storage permissions. To give users more control over their files and to limit file clutter, apps that target Android 10 (API level 29) and higher are given scoped access into external storage, or [scoped storage](https://developer.android.google.cn/training/data-storage#scoped-storage), by default. When scoped storage is enabled, apps cannot access the app-specific directories that belong to other apps.

### App compatibility features for data storage

Before your app is fully compatible with scoped storage, you can temporarily opt out by using one of the following methods:

* Target Android 9 (API level 28) or lower.

* If you target Android 10 (API level 29) or higher, set the value of `requestLegacyExternalStorage` to `true` in your app's manifest file:

  ``` xml
  <manifest ... >
    <!-- This attribute is "false" by default on apps targeting
         Android 10 or higher. -->
      <application android:requestLegacyExternalStorage="true" ... >
        ...
      </application>
  </manifest>
  ```

To test how an app targeting Android 9 or lower behaves when using scoped storage, you can opt in to the behavior by setting the value of `requestLegacyExternalStorage` to `false`.

> **Note:** Even if you opt out of scoped storage, you need the [`ACCESS_MEDIA_LOCATION`](https://developer.android.google.cn/reference/android/Manifest.permission#ACCESS_MEDIA_LOCATION) permission to read unredacted location information in images accessed using the [`MediaStore`](https://developer.android.google.cn/reference/android/provider/MediaStore) API.

åªè¦éµå®ˆè§„èŒƒæ¥ï¼Œä¸èƒ¡ä¹±åˆ›å»ºæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹ï¼Œé€‚é…éš¾åº¦å¾ˆå°ï¼Œç›¸åå¦‚æœé€‚é…éš¾åº¦å¤§ï¼Œè¯´æ˜äº†åœ¨å¤–éƒ¨å­˜å‚¨é‡Œèƒ¡ä¹±åˆ›å»ºæ–‡ä»¶ã€‚

###  æ£€æµ‹å¤–éƒ¨å­˜å‚¨æ˜¯å¦å¯ç”¨

Because external storage resides on a physical volume that the user might be able to remove, verify that the volume is accessible before trying to read app-specific data from, or write app-specific data to, external storage.

``` java
// Checks if a volume containing external storage is available
// for read and write.
private boolean isExternalStorageWritable() {
    return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED;
}

// Checks if a volume containing external storage is available to at least read.
private boolean isExternalStorageReadable() {
     return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED ||
            Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED_READ_ONLY;
}
```

On devices without removable external storage, use the following command to enable a virtual volume for testing your external storage availability logic:

``` shell
adb shell sm set-virtual-disk true
```

### é€‰å–ç‰©ç†å­˜å‚¨ä½ç½®

Sometimes, a device that allocates a partition of its internal memory as external storage also provides an SD card slot. This means that the device has multiple physical volumes that could contain external storage, so you need to select which one to use for your app-specific storage.

To access the different locations, call [`ContextCompat.getExternalFilesDirs()`](https://developer.android.google.cn/reference/androidx/core/content/ContextCompat#getExternalFilesDirs(android.content.Context, java.lang.String)). As shown in the code snippet, the first element in the returned array is considered the primary external storage volume. Use this volume unless it's full or unavailable.

``` java
File[] externalStorageVolumes =
        ContextCompat.getExternalFilesDirs(getApplicationContext(), null);
File primaryExternalStorage = externalStorageVolumes[0];
```

> **Note:** If your app is used on a device that runs Android 4.3 (API level 18) or lower, then the array contains just one element, which represents the primary external storage volume.

### è®¿é—®æ–‡ä»¶

``` java
File appSpecificExternalDir = new File(context.getExternalFilesDir(), filename);
```

> æ³¨æ„ä¸èƒ½å¤Ÿå¤šæ¬¡æ‰“å¼€æˆ–å…³é—­åŒä¸€ä¸ªæ–‡ä»¶

#### åˆ›å»ºç¼“å­˜æ–‡ä»¶

``` java
File externalCacheFile = new File(context.getExternalCacheDir(), filename);
```

#### åˆ é™¤ç¼“å­˜æ–‡ä»¶

``` java
externalCacheFile.delete();
```

#### å¤šåª’ä½“æ–‡ä»¶

If your app works with media files that provide value to the user only within your app, it's best to store them in app-specific directories within external storage, as demonstrated in the following code snippet:

``` java
@Nullable
File getAppSpecificAlbumStorageDir(Context context, String albumName) {
    // Get the pictures directory that's inside the app-specific directory on
    // external storage.
    File file = new File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName);
    if (file == null || !file.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created");
    }
    return file;
}
```

It's important that you use directory names provided by API constants like [`DIRECTORY_PICTURES`](https://developer.android.google.cn/reference/android/os/Environment#DIRECTORY_PICTURES). These directory names ensure that the files are treated properly by the system. If none of the [pre-defined sub-directory names](https://developer.android.google.cn/reference/android/os/Environment#fields) suit your files, you can instead pass `null` into `getExternalFilesDir()`. This returns the root app-specific directory within external storage.



## æŸ¥çœ‹ç©ºé—²ç©ºé—´

Many users don't have much storage space available on their devices, so your app should consume space thoughtfully.

If you know ahead of time how much data you're storing, you can find out how much space the device can provide your app by calling [`getAllocatableBytes()`](https://developer.android.google.cn/reference/android/os/storage/StorageManager#getAllocatableBytes(java.util.UUID)). The return value of `getAllocatableBytes()` might be larger than the current amount of free space on the device. This is because the system has identified files that it can remove from other apps' cache directories.

If there's enough space to save your app's data, call [`allocateBytes()`](https://developer.android.google.cn/reference/android/os/storage/StorageManager#allocateBytes(java.io.FileDescriptor, long)) to claim the space. Otherwise, your app can invoke an intent that includes the [`ACTION_MANAGE_STORAGE`](https://developer.android.google.cn/reference/android/os/storage/StorageManager#ACTION_MANAGE_STORAGE) action. This intent displays a prompt to the user, asking that they choose files on the device to remove so that your app can have the space it needs. If desired, this prompt can show the amount of free space available on the device. To show this user-friendly information, use the result of the following calculation:

``` java
StorageStatsManager.getFreeBytes() / StorageStatsManager.getTotalBytes()
```

The following code snippet shows an example of how your app can query free space on the device:

``` java
// App needs 10 MB within internal storage.
private static final long NUM_BYTES_NEEDED_FOR_MY_APP = 1024 * 1024 * 10L;

StorageManager storageManager =
        getApplicationContext().getSystemService(StorageManager.class);
UUID appSpecificInternalDirUuid = storageManager.getUuidForPath(getFilesDir());
long availableBytes =
        storageManager.getAllocatableBytes(appSpecificInternalDirUuid);
if (availableBytes >= NUM_BYTES_NEEDED_FOR_MY_APP) {
    storageManager.allocateBytes(
            appSpecificInternalDirUuid, NUM_BYTES_NEEDED_FOR_MY_APP);
} else {
    Intent storageIntent = new Intent();
    storageIntent.setAction(ACTION_MANAGE_STORAGE);
    // Display prompt to user, requesting that they choose files to remove.
}
```

> **Note:** You aren't required to check the amount of available space before you save your file. You can instead try writing the file right away, then catch an [`IOException`](https://developer.android.google.cn/reference/java/io/IOException) if one occurs. You may need to do this if you don't know exactly how much space you need. For example, if you change the file's encoding before you save it by converting a PNG image to JPEG, you don't know the file's size beforehand.