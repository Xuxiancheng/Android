# 什么是好代码

## 前言🐳

什么是好代码? 干净、整洁、命名规范、注释合理、高内聚低耦合 ....

大多数人写的代码都不能称之为好代码，一方面是由于自己的技能限制，另一方面也可能根本分不清好代码与坏代码之间的区别，下面是一些常见的代码坏味道。

## Long Method (过长函数)

`过长函数'简而言之就是函数长度超标了，包括横向和纵向

### *为什么过长函数是一种坏味道?*

横向过长会导致无法一眼就能看到这行代码的作用，影响阅读代码的效率

纵向过长就是出现了大函数，使得函数难以读懂，代码修改难度加大

### 如何解决函数过长的问题呢？


关于横向过长的问题，一半会在IDE中提前配置好最大的宽度，然后格式化代码即可解决。

比如在写Java8 Stream链式表达式的时候可能会过长；

``` java
List<String> nodes = list.stream().filter().filter().map.filter().collect(Collectors.toList()); // 可能会非常长
```

但是在*.*之前换行，这样看起来就不会很长了。

``` java
List<String> nodes = list.stream()
  .filter()
  .filter()
  .map
  .filter()
  .collect(Collectors.toList());
```

关于纵向过长的问题其实就是这个方法或者函数职责不够单一，一个函数中堆积太多功能。

重构的手段很简单：`Extract Method`，积极抽取函数或方法，隐藏细节保持职责单一。

## Large Class （过大的类）

过大的类也常被称为`上帝类`（God Class），上帝类一般指维护太多功能（违反单一职责原则），连上帝也看不懂的代码。

>  设计模式的六大原则有：
> Single Responsibility Principle：单一职责原则
> Open Closed Principle：开闭原则
> Liskov Substitution Principle：里氏替换原则
> Law of Demeter：迪米特法则
> Interface Segregation Principle：接口隔离原则
> Dependence Inversion Principle：依赖倒置原则
> 六个原则的首字母联合起来就是 SOLID，两个 L 当成一个。

那如何判断一个类是不是上帝类呢？

> 一般一个类同时满足以下3个条件就是上帝类：
> （1）CPFD (Capsules Providing Foreign Data) 从多个不相关类（模块）中引用数据。
> （2）WOC (Weighted Operation Count) 类的所有函数的圈复杂度之和超过65。
> （3）TCC (Tight Capsule Cohesion) TCC < 1/3 类需要具有低内聚的特性（类中直接相关的方法与全部方法之比小于1/3），也就是较少的private方法。

### 为什么过大的类是一种坏味道

过大的类承担了过多的责任，往往有很多重复代码，并且这些重复代码你还不容易发现，这基本就是坏味道的开始。

### 如何解决过大的类这种问题？

通过观察这个过大类的属性，看有没有一些属性有关联，如果有可以使用 `Extract Class` 将这些关联属性抽象到一个新类中，并将与这些属性相关的操作都 `Move` 到新的类中。

通过观察这个过大类的方法，看有没有一些函数或方法存在兄弟关联，如果有可以使用 `Extract Subclass`（提炼子类）的手段将这些方法提炼到子类中，子类可以继承父类。将相似的行为方法聚集在一起，拆分到多个类中，可以进一步将方法调用解耦开。

以上方法循环往复，一个大类就可以拆分为多个小的且职责单一的类。

## Duplicated Code （重复的类）

重复代码一般是由于复制粘贴造成的。需求迭代过程中为了不影响已有功能，通常是将之前的代码`copy`一份改改，然后匆匆上线。

### **那为什么重复的代码是一种坏味道呢？**

最直接的弊端就是如果你想修改一段代码逻辑，可能会遗漏，甚至需要多次修改才能确保全部修改完。

### **如何解决重复代码的问题？**

场景1:同一个类中两个方法含有相同的表达式

``` java
class A {
    public void method1() {
        logic1
        logic2
        logic3
    }
    public void method2() {
        logic1
        logic2
        logic4
    }
}

//修改后

class A {
    public void method1() {
        baseMethod();
        logic3
    }
    public void method2() {
        baseMethod();
        logic4
    }
    public void baseMethod() {
        logic1
        logic2
    }
}
```

**场景2：两个具有相同父类的子类内含有相同的表达式。**

``` java
class A extend Base {
    public void method1() {
        logic1
        logic2
        logic3
    }
}

class B extend Base {
    public void method2() {
        logic1
        logic2
        logic3
    }
}

//重构后

class Base {
    public void baseMethod() {
        logic1
        logic2
    }
}
class A extend Base {
    public void method1() {
        baseMethod();
        logic3
    }
}
class B extend Base {
    public void method2() {
        baseMethod();
        logic3
    }
}
```

**场景3：两个毫无相关的类出现重复代码。**

如果两个没有直接关联的类出现重复代码，可以考虑将重复的代码抽象到一个独立的普通类或者工具类中，调用方可以使用组合的方式调用。

## Long Parmeter List （过长的参数列）

全局变量是个邪恶的东西，数据是共享的并且每个线程都可以修改，太多了容易导致程序不可控，所以大家喜欢将变量以行参的方式传递，久而久之参数列越来越长了。

**为什么过长参数列是一种坏味道？**

方法参数的数量太多会导致代码可读性非常差，如果有多个重载方法，它们的方法参数都非常多，在写代码时很难判断该调用哪一个。

当一个方法需要新增功能，每次都可能会新增一个方法参数，这样导致调用方每次都要重新适配，小心被打哦，耗子尾汁。

**如何解决过长参数列这种坏味道？**

可以将多个参数封装到一个 `DTO 对象`中，方法间的对象通过对象传输而不是过长的参数。

特别需要提醒的是有些情况下长参数也是合理的，因为使用参数可以避免某些依赖关系的产生。在编码实践中我们可以通过观察长参数的方法，如果这个方法经常变动那你就要考虑重构这个方法了。基本原则：`事不过三，过三重构`。

## Shotgun Surgery（散弹式修改）

**为什么散弹式修改是一种代码坏味道？**

如果需要修改某个小功能，你需要在众多不同的类中做修改，首先很难找全，其次很可能会遗漏，这种问题一般称之为散弹式修改。

``` java
public class A {
    @Value("${db.mysql.url}")
    private String mysqlDbUrl;
}

public class B {
    @Value("${db.mysql.url}")
    private String mysqlDbUrl;
}
```

假如有多个类都使用了`db.mysql.url`这个变量，如果后面要将 `mysql` 切到 `Oracle`，那么可能会涉及到多处修改。**如何解决散弹式修改这种代码坏味道呢？**

可以使用 `Move Method` （搬移函数）和 `Move Field` （搬移字段）把所有需要修改的代码放进同一个类，如果暂时没有合适的类，就创建一个。

## Speculative Generality（夸夸其谈未来性）


听到这里你可以会鼓掌：牛叉啊，提前对功能模板预留了扩展性。但是不要急于鼓掌，你看技术总监的脸黑着呢，为什么呢？这位小伙伴的代码可能是一种坏味道：`夸夸其谈未来性`。

**为什么夸夸其谈未来性是一种代码坏味道？**

互联网需求迭代更新速度快，“未来可以”意味着当下并不需要，有时候过度的抽象和预留扩展也会让系统难以理解，并且可能**提前背上包袱**往前走。

代码上总是谈未来可能性，会让团队陷入泥沼。每次有业务变动，开发人员都会考虑各种未来可能性，预留足够多的扩展接口，这无疑极大增加了代码复杂度，让一个可能快速上线的需求变得慢下来。

**如何解决夸夸其谈未来性这种代码坏味道呢？**

在代码架构设计中有一个原则叫：`Simple Design` （简单设计原则）。

> 当实现当下业务代码时需要考虑四个原则：通过测试、揭示意图、消除重复、最少元素。
>
> 当需要为未来而写的代码时，可以干这些：
> （1）删除那些觉得未来有用的参数、代码、方法调用。
> （2）修正方法名，使方法名揭示当下业务场景的意图，避免抽象的技术描述词。

如果代码的改动确实是未来必然会出现的，那么还是建议保留。夸夸其谈未来性更多是指开发人员无依据臆测未来，导致代码模块被过度设计。

## Comments（过多的注释）

**为什么过多的注释是一种代码坏味道呢？**

好的注释可以辅助开发人员快速阅读理解代码，过多的注释或坏注释可能会降低代码的可读性。

在开发实践中经常有同学修改了代码但是注释没有同步修改，代码的实现已经与注释内容不一致，容易产生误导。

**如何解决过多的注释这种坏味道呢？**
（1）如果代码块不再使用请直接删除不要使用注释。
（2）方法、变量的命名尽量见名知意，避免用注释再解释一遍。
（3）如果较短的注释不能覆盖方法的含义，可能是这个方法职责不单一，可以考虑重构这个方法。